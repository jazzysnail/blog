---
title: 纯函数
date: 2017-05-22 22:38:57
tags: 
  - JS
---

函数为什么讲究 **纯**，最基本的要求便是 **安全** 二字。别的不谈，函数内部充斥着莫名其妙的依赖和对外部状态的更改,而且执行完毕后参数值连同着被更改了，这样的函数极难维护。

---

近来在写一个 `Vue` 组件时遇见这样一件事情，一个组件使用者在使用组件时，将一个实例对象使用 `Props` 传入了组件内部，组件处理完成后通过 `emit` 发送给了组件外部，然而使用者随即就将该结果再次赋值给了 `Props` 相同的对象，使得组件执行递归反复处理了几次才最总得到了非期许的值。

这让我觉得非常的尴尬，要我觉得组件本身是没有问题的。就组件本身而言无非就是将 UI 和处理逻辑封装起来根据输入得到输出，仅此而已。之所以得到一个非期许的值，举个简单的例子来解释：

``` js
let exArray = [1,3,5,7,3,9,4,2];
for (let i = 0; i < exArray.length; i++) {
  if (exArray[i] < 5) {
    exArray.splice(i, 1);
  }
}
console.log(exArray) // => [3, 5, 7, 9, 2]
```

上面的例子试图通过遍历数组来删除掉小于 5 的元素，然而结果不尽人意。为什么？如果把 for 循环体看做一个函数的话，那么每一次的删除操作都破坏了原先正确传入函数的参数，即数组的长度发生了改变，导致个别元素被异常跳过了。

我认为更优秀的实现方式应该是：
``` js
let exArray = [1,3,5,7,3,9,4,2];
let reArray = exArray.filter(val => val < 5);
console.log(exArray); // => [1, 3, 5, 7, 3, 9, 4, 2]
console.log(reArray); // => [1, 3, 3, 4, 2]
```

> 我们一般写函数都讲究一个**纯**字，既函数**对当做参数传入的对象不具有破坏性**，同时也**对依赖和更改保持诚实**，才能保证不污染外部状态。只要函数做到了尽可能的纯那么就足够了，不需要承担过多的处理逻辑，组件设计亦然。